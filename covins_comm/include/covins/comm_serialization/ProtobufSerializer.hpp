#pragma once

#include <string>    // For std::string
#include <vector>    // For std::vector
#include <cstdint>   // For uint8_t
#include <memory>    // For std::unique_ptr, std::make_unique
#include <map>       // For std::map

// Eigen includes for matrix/vector types
#include <eigen3/Eigen/Dense>

// Include the abstract interfaces
#include <covins/comm_serialization/ISerializer.hpp> // Ensure .hpp extension matches

// IMPORTANT: Include the generated Protobuf header here to fully define DataBuffer and its nested types
// This file is generated by protoc from data_buffer.proto and typically lives in the build directory
#include "data_buffer.pb.h"

namespace covins {

/**
 * @brief Concrete implementation of ISerializer and IDeserializer using Google Protocol Buffers.
 *
 * This class provides methods to serialize C++ data types into a Protobuf message
 * and deserialize them back from a Protobuf message, fulfilling the contracts
 * defined by ISerializer and IDeserializer. It relies on a pre-defined Protobuf
 * schema (e.g., DataBuffer.proto) to structure the data.
 */
class ProtobufSerializer : public ISerializer, public IDeserializer {
public:
    /**
     * @brief Constructor. Initializes the internal Protobuf message.
     */
    ProtobufSerializer();

    /**
     * @brief Destructor. Cleans up Protobuf message resources.
     */
    virtual ~ProtobufSerializer();

    // --- ISerializer interface implementation ---

    void write(const std::string& key, const std::string& value) override;
    void write(const std::string& key, int value) override;
    void write(const std::string& key, double value) override;
    void write(const std::string& key, bool value) override;
    void write(const std::string& key, const std::vector<uint8_t>& data) override;
    void write(const std::string& key, const Eigen::Matrix4d& transform) override;
    void write(const std::string& key, const Eigen::Vector3d& vector) override;

    std::vector<uint8_t> getSerializedData() const override;
    void reset() override;

    // --- IDeserializer interface implementation ---

    void setData(const std::vector<uint8_t>& data) override;
    std::string readString(const std::string& key) override;
    int readInt(const std::string& key) override;
    double readDouble(const std::string& key) override;
    bool readBool(const std::string& key) override;
    std::vector<uint8_t> readBinary(const std::string& key) override;
    Eigen::Matrix4d readTransform(const std::string& key) override;
    Eigen::Vector3d readVector3d(const std::string& key) override;

private:
    // This unique_ptr will hold the Protobuf message that we are building (for serialization)
    // or parsing (for deserialization).
    std::unique_ptr<covins::protobuf::DataBuffer> data_buffer_pb_;

    // Use the generated name for nested Entry type from Protobuf
    std::map<std::string, const covins::protobuf::DataBuffer_Entry*> deserialized_entries_;

    // Helper functions (declarations only)
    void ensureDataBufferInitialized();
    void populateDeserializedEntries();
};

// Declare the helper function 'getEntry' if it's a free function and used by the ProtobufSerializer.cpp
// Note: It needs to be declared outside the class, but its definition will be in ProtobufSerializer.cpp
const covins::protobuf::DataBuffer_Entry* getEntry(const std::string& key,
                                                     const std::map<std::string, const covins::protobuf::DataBuffer_Entry*>& entries);

} // namespace covins
